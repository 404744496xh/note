[TOC]

# 图论

## 基本概念

### 1、有向图

若E是有向边(也称弧)的有限集合时，则图G为有向图。弧是顶点的有序对，记为\<v, w>，其中v,w是顶点，v称为弧尾，w称为弧头，\<v,w>称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v。

### 2、无向图

若E是无向边(简称边)的有限集合时，则图G为无向图。边是顶点的无序对，记为(v, w)或(w,v),因为(v,w)=(w,v), 其中v,w是顶点。可以说顶点w和顶点v互为邻接点。边(v, w)依附于顶点w和v，或者说边(v, w)和顶点v, w相关联。

### 3、简单图

&#x20;一个图G若满足:①不存在重复边;②不存在顶点到自身的边，则称图G GG为简单图。数据结构中仅讨论简单图。

### 4、多重图

若图G 中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G GG为多重图。多重图的定义和简单图是相对的。

### 5、完全图（也称简单完全图）&#x20;

对于无向图，∣ E ∣的取值范围是0到n ( n − 1 ) / 2，有n ( n − 1 ) / 2 条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边。对于有向图 |E|的取值范围是0 到n ( n − 1 ) ，有n(n-1)条弧的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。

## 6、子图&#x20;

设有两个图G = ( V , E )和G ′ = ( V ′ , E ′ ) ， 若V ′  是V 的子集，且E ′  是E的子集，则称G ′  是G 的子图。若有满足V(G ′ )=V(G)的子图G ′ ，则称其为G 的生成子图。

> 注意:并非V和E的任何子集都能构成G的子图，因为这样的子集可能不是图，即E的子集中的某些边关联的顶点可能不在这个V的子集中。

### 7、连通、连通图和连通分量&#x20;

在无向图中，若从顶点v 到顶点w 有路径存在，则称v 和w 是连通的。若图G 中任意两个顶点都是连通的，则称图G 为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量。若一个图有n个顶点，并且边数小于n − 1，则此图必是非连通图。

> 注意:弄清连通、连通图、连通分量的概念非常重要。首先要区分极大连通子图和极小连通子图，极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边;极小连通子图是既要保持图连通又要使得边数最少的子图。

### 8、强连通图、强连通分量&#x20;

在有向图中，若从顶点v 到顶点w 和从顶点w 到项点v 之间都有路径,则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量，

> 注意:强连通图、强连通分量只是针对有向图而言的。一般在无向图中讨论连通性，在有向图中考虑强连通性。

### 9、生成树、生成森林

&#x20;连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n nn,则它的生成树含有n − 1 条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林。图G 2  ​ 的一个生成树如下图所示。

> 注意:包含无向图中全部顶点的极小连通子图，只有生成树满足条件，因为砍去生成树的任一条边，图将不再连通。

### 10、顶点的度、入度和出度

图中每个顶点的度定义为以该项点为一个端点的边的数目。&#x20;

对于无向图，顶点v的度是指依附于该顶点的边的条数，记为TD(v)。

无向图的全部顶点的度的和等于边数的2倍，因为每条边和两个顶点相关联。

对于有向图,顶点v 的度分为入度和出度,入度是以顶点v 为终点的有向边的数目，记为ID(v); 而出度是以顶点v 为起点的有向边的数目，记为OD(v)。顶点v 的度等于其入度和出度之和，即TD(v)=ID(v)+OD(v)。

有向图的全部顶点的入度之和与出度之和相等，并且等于边数。这是因为每条有向边都有一个起点和终点。

### 11、边的权和网

在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。

### 12、稠密图、稀疏图

边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。一般当图G满足∣ E ∣ < ∣ V ∣ l o g ∣ V ∣ |E| < |V|log|V|∣E∣<∣V∣log∣V∣时，可以将G GG视为稀疏图。

### 13、路径、路径长度和回路&#x20;

顶点v p 到顶点v q 之间的一条路径是指顶点序列v p , v i 1 , v i 2 , . . . , v i m , ，当然关联的边也可以理解为路径的构成要素。路径上边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有n 个顶点，并且有大于n − 1 条边，则此图一定有环。

### 14、 简单路径、简单回路

在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。

### 15、距离

从顶点u 出发到顶点v 的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v 根本不存在路径，则记该距离为无穷(∞)。

### 16、有向树

一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。

## 图的储存

### 邻接矩阵

用二维数组表示，定义全局变量G \[row] \[col],其中row是矩阵行数，col是矩阵列数。而G \[i] \[j]表示结点i和结点j之间存在路径的情况，无权图中，0表示不存在路径，1表示存在路径。有权图中，G \[i] \[j]中的值是边的权值，当路径不存在时用无穷大表示。无向图中G \[i] \[j]==G \[j] \[i] ；而有向图中G \[i] \[j] !=G \[j] \[i].

## 邻接表

邻接表的原理就是对每个在图上的顶点都创建了一个单链表，把该顶点上的边都存储在链表上。头节点存储图上的顶点信息，由顶点号和指向下一个结点的指针组成。其它结点由三部分组成，和头节点表示的顶点有边相关联的顶点号，边的权值和指向下一个结点的指针。如下图所示。

![](https://img-blog.csdnimg.cn/20200731084548610.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MzI5MjI2,size_16,color_FFFFFF,t_70)

这就是图和邻接表的对应关系，用链表来存储，极大的优化了存储效率，但是链表并不好实现，也不好操作，所以很多人到这里就会感到头疼。的确，直接的利用链表去实现图的存储会比较麻烦，但C++的STL库是一个非常有用的工具，其中的vector就可以很好的替代表。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200731084610434.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MzI5MjI2,size_16,color_FFFFFF,t_70 "在这里插入图片描述")

### 链式前向星

链式前向星和邻接表的思想非常相似，首先要先建一个结构体数组struct edge表示边,包含有int to,int next,int w三个数据域，分别表示边的终点，下一条边和边的权值。

```c++
struct edge
{
	int to;
	int next;
	int w;
};
```

除此之外还要定义一个静态数组head\[]，head的下标是结点号，对应的内容是该结点的第一条边。当head\[i]=j时，表示i结点的第一个边是j，即edge\[j]。因为在结构体中定义了三个数据域，其中next便是指下一条边，所以可以一步步找到其它所有边；通过to可以找到其它有边相连的结点。

此外存储边的时候，要设置addedge()函数，每新增一条边，to,next,head等信息都可能更新。

```c++
void addedge(int u, int v, int w)
{
	e[cnt].to = v;
	e[cnt].w = w;
	e[cnt].next = head[u];
	head[u] = cnt++;
}
```

代码：

```c++
#include<stdio.h>
#include<iostream>
#include<vector>
using namespace std;
const int N = 100;
struct edge
{
	int to;
	int next;
	int w;
};
edge e[N];
int head[N];
int cnt=0;
void addedge(int u, int v, int w)
{
	e[cnt].to = v;
	e[cnt].w = w;
	e[cnt].next = head[u];//指向结点u上一次存边的位置
	head[u] = cnt++;//更新最新的存放位置
}
int main()
{
	for (int i = 0;i < N;i++)
	{
		e[i].next = -1;//刚开始每个边都没有下一个边
		head[i] = -1;//刚开始不存在从结点i出发的边
	}
	int u, v, w, n, m,t;
	cin >> n >> m;
	while (m--)
	{
		cin >> u >> v >> w;
		addedge(u, v, w);
	}
	for (int i = 0;i < N;i++)
	{
		if (head[i] != -1)
		{
			for (int j = head[i];j != -1;j = e[j].next)
			{
				printf("边为%d %d %d\n", i, e[j].to, e[j].w);
			}
		}
	}
	return 0;
}
```

## 欧拉图

欧拉图是指通过图（无向图或有向图）中所有边且每边仅通过一次通路，相应的回路称为欧拉回路。具有欧拉回路的图称为欧拉图（E u l e r G r a p h Euler GraphEulerGraph），具有欧拉通路而无欧拉回路的图称为半欧拉图。（f r o m fromfrom百度百科）
**有没有发现很像小时候玩的一笔画问题？**
欧拉路分为欧拉通路和欧拉回路
欧拉通路：从一个点出发，不重复地经过每条边，从另一个点结束。
欧拉回路：从一个点出发，不重复地经过每条边，又回到该点结束。
**判断方法（性质）：**
无向图

> 通路：有且仅有两个点的度数为奇数，其他点的度数均为偶数。
> 回路：所有点的度数均为偶数。

有向图

> 通路：有一个点的出度比入度大 1,另一个点的出度比入度小 1 ，其他点的出度与入度相等。
> 回路：所有点的出度与入度相等。

