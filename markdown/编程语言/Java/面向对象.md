![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1720957286327-c1e756d5-c92b-4d58-ae2e-6e83051db310.png)

###### 面向过程&面向对象
+ 面向过程思想
+ 步骤清晰简单，第一步做什么，第二步做什么……
+ 面对过程适合处理一些较为简单的问题
+ 面向对象思想
+ 物以类聚，**分类**的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。
+ 面向对象适合处理复杂的问题，适合处理需要多人协作的问题
+ 对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。

## 什么是面向对象
+ 面向对象编程（Object-Oriented Programming,OOP）
+ 面向对象的本质就是：

**以类的方式组织代码，以对象的组织封装数据。**

+ 三大特性：
+ 封装
+ 继承
+ 多态

# 类与对象的关系
### 类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。（相当于模板）
+ 动物、植物、手机、电脑……
+ Person类、Pet类、Car类等，这些类都是用来描述/定义某一类具体的事物应该具备的特点和行为
+ 类：

静态的属性——属性

动态的行为——方法

### 对象是抽象概念的具体实例
+ 比如张三就是人的一个具体实例，张三家里的旺财就是狗的一个具体实例。
+ 能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。
+ 以认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象
+ 以代码运行角度考虑是先有类后有对象。类是对象的模板。
+ 对象是通过引用来操作的：栈——>堆
+ 属性：字段（Fileld）或成员变量
+ 默认初始化
+ 数字：0或0.0
+ char：u0000
+ boolean：false
+ 引用：null

修饰符  属性类型  属性名 = 属性值

## 创建与初始化对象
+ 必须使用new关键字创建对象，比如：

```java
Person ChestnutCat = new Person();

```

+ 对象的属性（例）

```java
ChestnutCat.name

```

+ 对象的方法（例）

```java
ChestnutCat.sleep()

```

+ 使用new关键字创建时，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中的构造器的调用。
+ 类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点：
+ 1.必须和类的名字相同
+ 2.必须没有返回类型，也不能写void

# 构造器
+ 特点
1. 和类名相同
2. 没有返回值
+ 作用
+ 使用new关键字，本质是在调用构造方法
+ 初始化对象的值
+ 注意点：

定义有参构造后，如果想使用无参构造，需要显示地定义一个无参的构造（有参显示调用无参）

+ Alt+Insert 生成一个构造器

# 封装
+ 我们程序设计要追求**“高内聚，低耦合”**。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量 的方法给外部使用。
+ 封装（数据的隐藏）

通常，应禁止直接访问一个对象中数据的实际表示，而通过操作接口来访问，这称为信息隐藏。

+ 属性私有（private），get/set
+ 封装的意义：
+ 提高程序的安全性，保护数据
+ 隐藏代码的重要细节
+ 统一接口
+ 系统可维护性增加了

# 继承
+ 继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。
+ extands

的意思是“扩展”。子类是父类的扩展。

+ Java中类只有单继承，没有多继承！
+ 继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。
+ 继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extands来表示。
+ 子类和父类之间，从意义上讲应该具有“is a”的关系
+ object类
+ super
+ 调用父类的构造方法，必须在构造方法的第一行
+ super必须只能出现在子类的方法或者构造方法中
+ super和this不能同时调用构造方法
+ 方法重写

### super&this
+ 代表的对象不同：

this：本身调用者为这个对象

super：代表父类对象的调用

+ 前提

this：没有继承也可以使用

super：只能在继承条件下使用

+ 构造方法

this()：本类的构造

super()：父类的构造

### 方法重写（Override）
+ 重写都是方法的重写，与属性无关
+ 需要有继承关系，子类重写父类的方法
+ 【注意】

1.方法名必须相同

2.参数列表必须相同

3.修饰符：范围可以扩大（如把private扩大成public）

4.抛出的异常：范围，可以被缩小，但不能扩大

+ 子类的方法和父类必须一致，方法体不能相同
+ 重写的应用环境：

父类的功能，子类不一定需要，或者不一定满足

# 多态
+ 动态编译，使可扩展性更强
+ 即同一方法可以根据发送对象的不同而采用多种不同的行为方式
+ 一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多
+ 多态存在的条件：
+ 有继承关系
+ 子类重写父类方法
+ 父类引用指向子类对象
+ 注意：
1. 多态是方法的多态，属性没有多态性
2. 父类和子类要有联系（ClassCastEcception 类型转换异常）
3. 存在条件：继承关系、方法需要重写、父类的引用指向子类对象
4. 父类引用指向子类对象
5. 把子类转换为父类——向上转型
6. 把父类转换为子类——向下转型（强制转换，可能会丢失精度）
+ 多态的意义：方便方法的调用，减少重复的代码

### instanceof
+ 用于判断一个对象是什么类型（通过对比判断变量的指向关系实现）

```java
public class Application{
   public static void main(String[] args){
//Object > String  
//Object > Person > Teacher
//Object > Person > Student
  
 System.out.println(object instanceof Student);//true
 System.out.println(object instanceof Person);//true
 System.out.println(object instanceof Object);//true
 System.out.println(object instanceof Teacher);//False
 System.out.println(object instanceof String);//False

Person person = new Student();
 System.out.println(person instanceof Student);//true
 System.out.println(person instanceof Person);//true
 System.out.println(person instanceof Object);//true
 System.out.println(person instanceof Teacher);//False
 System.out.println(person instanceof String);//编译报错！

Student student = new Student();
 System.out.println(student  instanceof Student);//true
 System.out.println(student instanceof Person);//true
 System.out.println(student instanceof Object);//true
 System.out.println(student instanceof Teacher);//编译报错！
 System.out.println(student instanceof String);//编译报错！

//总的来说，是T还是F，就是看 System.out.println(X instanceof Y); 能不能编译通过
   }
}

```

## static关键字
+ 构造静态变量、静态方法等
+ static方法属于类，不属于实例
+ 含static的代码最优先执行，且只执行一次，所以可以通过static赋初始值

### final关键字
1）final 修饰变量，表示变量的值不可改变，此时该变量可被称为常量。

2）final 修饰方法，表示方法不能被子类重写；

重写概念：子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写，又称为方法覆盖。

3）final 用在类的前面表示该类不能有子类，即该类不可以被继承。

## 抽象类
+ abstract

修饰符可以用来修饰方法，也可以用来修饰类。如果修饰方法，那么该方法就是抽象方法；如果修饰类，那么该类就是抽象类。

+ 抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。
+ 抽象类不能使用new关键字来创建对象，它是用来让子类继承的。
+ 抽象方法只有方法的声明，没有方法的实现，它是用来让子类实现的。
+ 抽象方法必须在抽象类中
+ 子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。

```java
//抽象类
public abstract class Action{

//抽象方法，只有方法名字，没有方法的实现
   public abstract void doSomething();

   }//抽象的抽象————>约束

```

+ 抽象类的意义
+ 因为不能被实例化，所以它可以通过方法的覆盖实现多态的属性，也就是运行期绑定
+ 抽象类将事物的共性提取出来，由子类去继承和实现，使代码更易扩展、易维护。

# 接口（interface）
+ 普通类：只有具体实现
+ 抽象类：具体实现和规范（抽象方法）都有
+ 接口：只有规范（自己无法写方法）
+ 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是……则必须能……”的思想。
+ 接口的本质是契约

，就像人间的法律一样，制定好之后大家都遵守。

+ 接口中的所有定义的方法其实都是被抽象的。
+ OO的精髓，是对对象的抽象，最能体现这一点的就是接口。我们讨论设计模式都只针对具备了抽象能力的语言（比如C++、Java、C#等），就是因为设计模式所研究的实际上就是如何去合理地抽象。
+ 利用接口，可以实现伪造的“多继承”

### 内部类
+ 内部类就是在一个类的内部再定义一个类，比如：A类中定义一个B类，那么B类相对于A类来说就是一个内部类，而A类相对B类来说就是外部类了。
+ 成员内部类
+ 静态内部类
+ 局部内部类
+ 匿名内部类

