## Java 集合框架
早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。

虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。

集合框架被设计成要满足以下几个目标。

+ 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。
+ 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。
+ 对一个集合的扩展和适应必须是简单的。

为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： 

![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1720957297033-b01717a0-543b-4be6-aa6f-0552816153f0.png)

从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 [ArrayList](https://www.runoob.com/java/java-arraylist.html)、[LinkedList](https://www.runoob.com/java/java-linkedlist.html)、[HashSet](https://www.runoob.com/java/java-hashset.html)、LinkedHashSet、[HashMap](https://www.runoob.com/java/java-hashmap.html)、LinkedHashMap 等等。

集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：

+ 接口：

是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象

+ 实现（类）：

是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。

+ 算法：

是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。

除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中

![](https://cdn.nlark.com/yuque/0/2024/jpeg/46412986/1728093041475-8ae64db3-adf7-4b69-ad27-afd44825d037.jpeg)

---

## <font style="color:rgb(79, 79, 79);">01 初识集合</font>
### <font style="color:rgb(79, 79, 79);">> 集合是什么？为什么要用集合？</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">保存数据会经常使用到数组，但数组存在以下几个缺陷:</font>
    1. <font style="color:rgba(0, 0, 0, 0.75);">长度开始时必须指定，且一旦指定，不能更改；</font>
    2. <font style="color:rgba(0, 0, 0, 0.75);">保存的必须为同一类型的元素；</font>
    3. <font style="color:rgba(0, 0, 0, 0.75);">使用数组进行增加元素的步骤比较麻烦；</font>

```plain
//例如 创建一个 Play 数组
Play[] p = new Play[1]; //大小是1
p[0] = new Play();
//增加新的Play对象
Play[] p2 = new Play[p.length+1];//新建数组
//然后再用循环拷贝p数组的元素到p2中，很繁琐
```

<font style="color:rgb(77, 77, 77);">这个时候就需要用一个比数组要“高级的容器”来解决，这就是</font>**<font style="color:rgb(77, 77, 77);">集合</font>**<font style="color:rgb(77, 77, 77);">：</font>

1. <font style="color:rgba(0, 0, 0, 0.75);">可以动态保存任意多个不同类型对象，使用方便；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">提供了一系列方便的操作对象的方法：add、remove、set、get等；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">使用集合添加、删除新元素要简单的多；</font>

### <font style="color:rgb(79, 79, 79);">> 集合的框架体系</font>
<font style="color:rgb(77, 77, 77);">Java的集合类有很多，主要分为两大类：  
</font>![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093041513-112315af-3fcc-467c-94db-e82cf3a98a41.png)<font style="color:rgb(77, 77, 77);">  
</font>![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093041611-8b49e839-48f2-4b0f-8eb8-d42a0ec4794f.png)

<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">单列集合：</font>![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093042008-4b67bd2d-590e-47d9-96b1-6dc0b97e207c.png)<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">  
</font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">双列集合：</font>![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093042072-7363411a-6e7d-4907-a64a-ac64c71aff4b.png)

```plain
//单列集合
ArrayList arrayList = new ArrayList();
arrayList.add("Jack");
arrayList.add("Tom");

//双列集合
HashMap hashMap = new HashMap();
hashMap.put("No.1","我");
hashMap.put("No.2","你");
```

---

## <font style="color:rgb(79, 79, 79);">02</font><font style="color:rgb(79, 79, 79);"> </font>[<font style="color:rgb(79, 79, 79);">Collection接口</font>](https://so.csdn.net/so/search?q=Collection%E6%8E%A5%E5%8F%A3&spm=1001.2101.3001.7020)
<font style="color:rgb(77, 77, 77);">Collection接口实现类的特点：</font>

```plain
public interface Collection<E> extends Iterable<E>
```

1. <font style="color:rgba(0, 0, 0, 0.75);">Collection实现子类可以存放多个元素，每个元素可以是Object</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">有些Collection的实现类，可以存放重复的元素，有些不可以；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">有些Collection的实现类，有些是有序的（List），有些则不是有序（Set）；</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">Collection接口没有直接的实现子类，是通过它的子接口List和Set来实现的；</font>

<font style="color:rgb(77, 77, 77);">（----> 这些方法是 List 和 Set 都有的）</font>

### <font style="color:rgb(79, 79, 79);">> Collection接口常用方法</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">add</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 添加单个元素；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">remove</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 删除指定元素；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">contains</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 查找元素是否存在；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">size</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 获取元素个数；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">isEmpty</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 判断是否为空；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">clear</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 清空；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">addAll</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 添加多个元素；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">containaAll</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">：查找多个元素是否都存在；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">removeAll</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 删除多个元素；</font>

<font style="color:rgb(77, 77, 77);">以 ArrayList 实现类来演示：</font>

```plain
import java.util.ArrayList;
import java.util.List;

public class CollectionMethod {
    public static void main(String[] args) {
        //1.add：添加单个元素
        List list = new ArrayList();
        list.add("字符串");
        list.add(128);//list.add(new Integer(10))
        list.add(true);
        System.out.println("list="+list);//list=[字符串, 128, true]

        //2.remove：删除指定元素
        //list.remove(0);//删除第一个元素
        //System.out.println("list="+list);//list=[128, true]
        list.remove("字符串");//指定删除某个元素
        System.out.println("list="+list);//list=[128, true]

        //3.contains：查找某个元素是否存在
        System.out.println(list.contains(128));//true

        //4.size：返回元素个数
        System.out.println(list.size());//2

        //5.isEmpty：判断是否为空
        System.out.println(list.isEmpty());//false

        //6.clear：清空
        list.clear();
        System.out.println("list= "+list);//list= []

        //7.addAll：添加多个元素
        ArrayList list2 = new ArrayList();
        list2.add("开心");
        list2.add("每");
        list2.add(1);
        list2.add("天");
        list.addAll(list2);//传入一个集合
        System.out.println("新的list："+list);//新的list：[开心, 每, 1, 天]

        //8.containsAll：查找多个元素是否存在
        System.out.println(list.containsAll(list2));//true

        //9.removeAll：删除多个元素
        list.removeAll(list2);
        System.out.println("list="+list);//list=[]
    }
}
```

### <font style="color:rgb(79, 79, 79);">> Collection接口遍历元素：使用Iterator（迭代器）</font>
1. <font style="color:rgba(0, 0, 0, 0.75);">Iterator对象称为迭代器，主要用于遍历Collection集合中的元素；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">所有实现了Collection接口的集合类都有一个</font><font style="color:rgba(0, 0, 0, 0.75);"> </font>**<font style="color:rgba(0, 0, 0, 0.75);">iterator( )</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">方法，用以返回一个实现了Iterator接口的对象，即返回一个迭代器；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">Iterator仅用于遍历集合，Iterator本身并不存放对象；</font>

```plain
迭代器执行原理：
Iterator iterator = new coll.iterator(); 得到一个集合迭代器
hasNext() :判断是否还有下一个元素
while(iterator.hasNext()){
	next()作用:指针下移，将下移后以后集合位置上的元素返回
	System.out.println(iterator.next());
}
```

<font style="color:rgb(77, 77, 77);">每 next() 一次，箭头下移一次：  
</font>![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093042371-e4b33151-1f6d-431b-99b6-2a33ab8f60b0.png)

<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">注意：在调用 iterator.next( ) 方法之前，必须要调用iterator.hasNext( ) 进行检测；若不调用，且下一条记录无效，直接调用 iterator.next( ) 会抛出 NoSuchElementException异常。</font>

```plain
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class CollectionIterator {
    public static void main(String[] args) {
        Collection col = new ArrayList();

        col.add(new Book("三国演义","罗贯中",10.1));
        col.add(new Book("红楼梦","曹雪芹",34.6));
        col.add(new Book("西游记","吴承恩",28.8));
        System.out.println("col : "+col);
//col : [Book{name='三国演义', author='罗贯中', price=10.1}, Book{name='红楼梦', author='曹雪芹', price=34.6}, Book{name='西游记', author='吴承恩', price=28.8}]
        
        //遍历 col
        //1.先得到col集合对应的迭代器
        Iterator iterator = col.iterator();
        
        //2.使用while循环遍历
        //快捷键快速生成while循环 输入itit回车即可
        //crtl+j 可以查看当前所有快捷键
        while(iterator.hasNext()){ //判断是否还有数据
            //next()返回下一个元素，类型是Object
            Object obj = iterator.next();
            System.out.println(obj);
            //Book{name='三国演义', author='罗贯中', price=10.1}
            //Book{name='红楼梦', author='曹雪芹', price=34.6}
            //Book{name='西游记', author='吴承恩', price=28.8}
        
        //3.当退出while循环后，此时iterator迭代器指向最后的元素
        //iterator.next(); --> NoSuchElementException
        //4.若还要使用迭代器，需要重置迭代器
        iterator = col.iterator();             
        }
    }
}

class Book{
    private String name;
    private String author;
    private double price;

    public Book(String name, String author, double price) {
        this.name = name;
        this.author = author;
        this.price = price;
    }

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                ", author='" + author + '\'' +
                ", price=" + price +
                '}';
    }
}
```

### <font style="color:rgb(79, 79, 79);">> Collection接口遍历元素：增强 for 循环</font>
<font style="color:rgb(77, 77, 77);">增强for循环，可以代替 iterator迭代器，特点：增强for循环就是简化版的iterator，本质一样，只能用于遍历集合或数组；</font>

<font style="color:rgb(77, 77, 77);">基本语法：</font>

```plain
for(元素类型 元素名 : 集合名或数组名){
		访问元素
}
```

```plain
import java.util.ArrayList;
import java.util.Collection;

public class CollectionIterator {
    public static void main(String[] args) {
        Collection col = new ArrayList();

        col.add(new Book("三国演义","罗贯中",10.1));
        col.add(new Book("红楼梦","曹雪芹",34.6));
        col.add(new Book("西游记","吴承恩",28.8));

        //增强for循环  不仅可以用于集合，数组也同样适用
        //底层仍然是迭代器iterator 相当于简化版迭代器
        //快捷键 输入I后回车
        for (Object book:col) {
            System.out.println(book);
        }
        //Book{name='三国演义', author='罗贯中', price=10.1}
        //Book{name='红楼梦', author='曹雪芹', price=34.6}
        //Book{name='西游记', author='吴承恩', price=28.8}

    }
}

class Book{
    private String name;
    private String author;
    private double price;

    public Book(String name, String author, double price) {
        this.name = name;
        this.author = author;
        this.price = price;
    }

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                ", author='" + author + '\'' +
                ", price=" + price +
                '}';
    }
}
```

---

## <font style="color:rgb(79, 79, 79);">03 List接口</font>
![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093042453-8ca807d6-bd94-4b08-a1b1-11ea9657f9af.png)

+ <font style="color:rgba(0, 0, 0, 0.75);">List集合类中元素有序（即添加和取出顺序一致），且可重复</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">List集合中的每个元素都有其对应的顺序索引，即支持索引；</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">List容器中的元素都对应一个整数型的序号记其在容器中的位置，可以根据序号存取容器中的元素</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">List常用接口有 ArrayList、LinkedList、Vector</font>

```plain
//1.List集合类中元素有序（即添加和取出顺序一致），且可重复
        List list = new ArrayList();
        list.add("Jack");
        list.add("Tom");
        list.add("Marry");
        list.add("Marry");
        System.out.println(list);
        //[Jack, Tom, Marry, Marry]取出输出顺序和存放顺序一致,且可重复

        //2.List集合中的每个元素都有其对应的顺序索引，即支持索引
        System.out.println(list.get(2));//Marry
        //3.List容器中的元素都对应一个整数型的序号记其在容器中的位置，可以根据序号存取容器中的元素
```

### <font style="color:rgb(79, 79, 79);">> List 接口的常用方法</font>
1. <font style="color:rgba(0, 0, 0, 0.75);">void add (int index,Object ele) ：在index位置插入ele元素；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">boolean addAll (int index,Collection eles) ：从index位置开始将eles集合中的所有元素添加进来；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">Object get (int index) ：获取指定index位置的元素；</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">int indexOf (Object obj) ：返回obj在集合中首次出现的位置；</font>
5. <font style="color:rgba(0, 0, 0, 0.75);">int lastIndexOf (Object obj) ：返回obj在集合中末次出现的位置；</font>
6. <font style="color:rgba(0, 0, 0, 0.75);">Object remove (int index) ：移除指定index位置的元素，并返回此元素；</font>
7. <font style="color:rgba(0, 0, 0, 0.75);">Object set (int index,Object ele) ：设置指定index的位置的元素为ele，相当于是替换；</font>
8. <font style="color:rgba(0, 0, 0, 0.75);">List subList (int fromIndex,int toIndex) ：返回从fromIndex到toIndex位置的子集合；</font>

<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">更多方法可以自行JDK</font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> </font>[<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">API在线查询</font>](https://www.matools.com/api/java8)<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> </font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">或</font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> </font>[<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">下载中文版JavaAPI帮助文档【免费0积分下载】</font>](https://download.csdn.net/download/Lov1_BYS/86512924)

```plain
//向上转型，用List来接收ArrayList
List list = new ArrayList();

//1. void add (int index,Object ele) ：在index位置插入ele元素；
list.add("开心的你");
list.add(0,"帅气的我");//在0位置插入
System.out.println(list);//[帅气的我, 开心的你]

//2. boolean addAll (int index,Collection eles) ：从index位置开始将eles集合中的所有元素添加进来；
List list1 =  new ArrayList();
list1.add("Jack");list1.add("Tom");list1.add("Marry");
list.addAll(1,list1);
System.out.println(list);//[帅气的我, Jack, Tom, Marry, 开心的你]

//3. Object get (int index) ：获取指定index位置的元素；
System.out.println(list.get(0));//帅气的我

//4. int indexOf (Object obj) ：返回obj在集合中首次出现的位置；
System.out.println(list.indexOf("开心的你"));//4

//5. int lastIndexOf (Object obj) ：返回obj在集合中末次出现的位置；
list.add("Jack");
System.out.println(list.lastIndexOf("Jack"));//5

//6. Object remove (int index) ：移除指定index位置的元素，并返回此元素；
System.out.println(list.remove(5));//Jack
System.out.println(list);//[帅气的我, Jack, Tom, Marry, 开心的你]

//7. Object set (int index,Object ele) ：设置指定index的位置的元素为ele，相当于是替换；
list.set(1,"!!!");
System.out.println(list);//[帅气的我, !!!, Tom, Marry, 开心的你]

//8. List subList  (int fromIndex,int toIndex) ：返回从fromIndex到toIndex位置的子集合；
//返回的子集合： [fromIndex,toIndex) 左闭右开
System.out.println(list.subList(2,4));//[Tom, Marry]
```

### <font style="color:rgb(79, 79, 79);">> List的三种遍历方式</font>
```plain
import java.util.*;

public class ListFor {
    public static void main(String[] args) {
        //List的实现接口子类ArrayList LinkedList Vector
        //List list = new ArrayList();
        //List list = new LinkedList();
        List list = new Vector();
        list.add("熊大");
        list.add("熊二");
        list.add("光头强");

        //迭代器iterator遍历
        Iterator iterator = list.iterator();
        while(iterator.hasNext()){
            Object next = iterator.next();
            System.out.println(next);
        }

        //增强for遍历
        for (Object o:list) {
            System.out.println(o);
        }

        //普通遍历
        for (int i=0;i<list.size();i++){
            System.out.println(list.get(i));
        }
    }
}
```

### <font style="color:rgb(79, 79, 79);">> List 排序练习</font>
```plain
import java.util.ArrayList;
import java.util.List;

public class Demo {
    public static void main(String[] args) {
        //List list = new ArrayList();
        //List list = new LinkedList();
        List list = new Vector();
        list.add(new Book("红楼梦", 36.4f, "曹雪芹"));
        list.add(new Book("水浒传", 19.9f, "施耐庵"));
        list.add(new Book("西游记", 28.8f, "吴承恩"));

        //遍历
        for(Object o:list){
            System.out.println(o);
        }

        //冒泡排序
        sort(list);
        System.out.println("---- 排序后 ----");
        for(Object o:list){
            System.out.println(o);
        }
    }
    //静态方法：冒泡排序
    //要求价格从小到大
    public static void sort(List list){

        for (int i=0;i<list.size();i++){
            for (int j=0;j<list.size()-1-i;j++){
                //取出对象book
                Book book1 = (Book) list.get(j);
                Book book2 = (Book) list.get(j+1);
                if(book1.getPrice()>book2.getPrice()){
                    //交换
                    list.set(j,book2);
                    list.set(j+1,book1);
                }

            }
        }
    }
}
class Book{
    private String name;
    private float price;
    private String author;

    @Override
    public String toString() {
        return "书名： "+name+"  价格： "+price+"  作者： "+author;
    }

    public Book(String name, float price, String author) {
        this.name = name;
        this.price = price;
        this.author = author;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public String getName() {
        return name;
    }

    public float getPrice() {
        return price;
    }

    public String getAuthor() {
        return author;
    }
}
```

#### <font style="color:rgb(79, 79, 79);">※ ArrayList 使用注意事项</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">允许存放任何元素，包括空元素null</font>

```plain
ArrayList list = new ArrayList();
list.add(null);
list.add("OK")；
list.add(null);
System.out.println(list);
//[null,OK,null]
```

+ <font style="color:rgba(0, 0, 0, 0.75);">ArrayList 是由数组来实现数据存储的；</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">ArrayList基本等同于 Vector ，除了 ArrayList是线程不安全的，但执行效率高，在</font>**<font style="color:rgba(0, 0, 0, 0.75);">多线程的情况下不建议用ArrayList</font>**<font style="color:rgba(0, 0, 0, 0.75);">；</font>

#### <font style="color:rgb(79, 79, 79);">※ ArrayList 底层结构</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">ArrayList中维护了一个Object类型的数组  
</font><font style="color:rgba(0, 0, 0, 0.75);">transient Object[ ] elementData; //transient 短暂的 表示该属性不会被序列化</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0 ，第一次添加则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5 倍；</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">如果使用的是指定大小的构造器，则初始扩容elementData容量为指定大小，如果需要再次扩容，则直接扩容为1.5倍；</font>

#### <font style="color:rgb(79, 79, 79);">※</font><font style="color:rgb(79, 79, 79);"> </font><font style="color:rgb(78, 161, 219);">Vector</font><font style="color:rgb(79, 79, 79);"> </font><font style="color:rgb(79, 79, 79);">底层结构</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">Vector 底层也是一个对象数组，protected Object[ ] elementData；</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">Vector 是线程同步的，即线程安全，Vector类的操作方法带有synchronized</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">在开发中，需要线程同步安全时，考虑使用Vector</font>

#### <font style="color:rgb(79, 79, 79);">※ LinkedList 底层结构 （双向链表和增删改查案例）</font>
![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093042528-89cf8fda-d022-4a3f-b977-f6a583339459.png)

+ <font style="color:rgba(0, 0, 0, 0.75);">LinkedList 实现了双向链表和双端队列的特点</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">可以添加任意元素（元素可以重复），包括null；</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">线程不安全，没有实现同步</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">LinkedList底层维护了一个双向链表；</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">LinkedList中维护了两个属性first和last分别指向 首节点 和 尾节点；</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点，最终完成双向链表；</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">所以 LinkedList的元素的添加和删除不是通过数组完成的，相对来说效率较高；</font>

**<font style="color:rgb(77, 77, 77);">双向链表的模拟：</font>**

```plain
public class TestLinkedList01 {
    public static void main(String[] args) {
        //模拟一个简单的双向链表
        Node jack = new Node("Jack");
        Node tom = new Node("Tom");
        Node marry = new Node("Marry");

        //连接三个节点，形成双向链表
        //jack -> tom -> marry
        jack.next = tom;
        tom.next = marry;
        //jack <- tom <- marry
        marry.pre = tom;
        tom.pre = jack;

        Node first = jack;//让first引用指向jack，就是双向链表的首节点
        Node last = marry;//让last引用指向marry，就是双向链表的尾节点

        //演示 从头到尾 遍历
        System.out.println("--------- 从头到尾的遍历 --------");
        while(true){
            if(first == null){
                break;
            }
            //输出first信息
            System.out.println(first);
            first = first.next;//输出完以后，first指向下一个
            /*
                    Node name = Jack
                    Node name = Tom
                    Node name = Marry
                    进程已结束,退出代码0
             */
        }
        //从尾到头的遍历
        System.out.println("--------- 从尾到头遍历 --------");
        while(true){
            if(last == null){
                break;
            }
            //输出last信息
            System.out.println(last);
            last = last.pre;//输出完以后，first指向下一个
            /*
                    Node name = Marry
                    Node name = Tom
                    Node name = Jack
             */
        }

        //演示链表的添加对象/数据
        //在tom和marry之间插入一个对象
        //1.先创建一个Node节点,name为smith
        Node smith = new Node("Smith");
        //2.把smith加入双向链表
        smith.next = marry;
        smith.pre = tom;
        marry.pre = smith;
        tom.next = smith;
        //3.让first再次指向jack
        first =  jack;
        //演示 从头到尾 遍历
        System.out.println("--------- 插入smith后 从头到尾的遍历 --------");
        while(true){
            if(first == null){
                break;
            }
            //输出first信息
            System.out.println(first);
            first = first.next;//输出完以后，first指向下一个
        }/*
                Node name = Jack
                Node name = Tom
                Node name = Smith
                Node name = Marry
        */


    }

}


//定义一个Node类，Node对象表示双向链表的一个节点
class Node{
    public Object item;//真正存放数据的地方
    public Node next;//指向下一个节点
    public Node pre;//指向前一个节点
    public Node(Object name){
        this.item  = name;
    }
    public String toString(){
        return "Node name = "+item;
    }
}
```

**<font style="color:rgb(77, 77, 77);">LinkedList的增删改查案例：</font>**

```plain
import java.util.Iterator;
import java.util.LinkedList;

public class LinkListCRUD {
    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();

        //增
        linkedList.add(1);//size=0添加一个新节点，首尾指针都指向这个新节点
        linkedList.add(2);//last指向新节点，first还是指向第一个节点，next指向新节点
        linkedList.add(3);
        System.out.println("增后： "+linkedList);

        //删
        linkedList.remove();//默认删除第一个
        System.out.println("删后： "+linkedList);//就是去掉指针

        //改
        linkedList.set(1,999);
        System.out.println("改后： "+linkedList);


        //查
        //get(1) 得到双向链表的第二个对象
        Object o = linkedList.get(1);
        System.out.println(o);//999

        //因为LinkedList是实现了List接口，所以遍历方式：
        Iterator iterator = linkedList.iterator();
        while (iterator.hasNext()) { //快捷输入itit
            Object next =  iterator.next();
            System.out.println(next);
        }
        //还有增强for 和普通for 遍历
    }
}
```

<font style="color:rgb(77, 77, 77);">(可以自行debug看一下调用方法的实现)</font>

---

### <font style="color:rgb(79, 79, 79);">> ArrayList 和 LinkedList 比较</font>
| **<font style="color:rgb(79, 79, 79);">集合</font>** | **<font style="color:rgb(79, 79, 79);">底层结构</font>** | **<font style="color:rgb(79, 79, 79);">增删的效率</font>** | **<font style="color:rgb(79, 79, 79);">改查的效率</font>** |
| :---: | :---: | :---: | :---: |
| <font style="color:rgb(79, 79, 79);">ArrayList</font> | <font style="color:rgb(79, 79, 79);">可变数组</font> | <font style="color:rgb(79, 79, 79);">较低，数组扩容</font> | <font style="color:rgb(79, 79, 79);">较高</font> |
| <font style="color:rgb(79, 79, 79);">LinkedList</font> | <font style="color:rgb(79, 79, 79);">双向链表</font> | <font style="color:rgb(79, 79, 79);">较高，通过链表追加</font> | <font style="color:rgb(79, 79, 79);">较低</font> |


<font style="color:rgb(77, 77, 77);">如何选择 ArrayList 和 LinkedList :</font>

1. <font style="color:rgba(0, 0, 0, 0.75);">如果改查的操作较多，选择 ArrayList；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">如果增删的操作较多，选择 LinkedList；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">一般程序中，80%-90%都是查询，因此大部分会使用ArrayList；</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">在项目中，灵活选择，可以一个模块用LinkedList，一个模块用ArrayList；</font>

<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">多线程的情况还是考虑 Vector ，因为它是线程安全的</font>

---

## <font style="color:rgb(79, 79, 79);">04 Set接口</font>
![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093042811-517aab85-ce02-4b14-bc2a-abb260654614.png)

<font style="color:rgb(77, 77, 77);">Set 接口介绍：</font>

1. <font style="color:rgba(0, 0, 0, 0.75);">无序（添加和取出的顺序不一致），没有索引；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">不允许重复元素，所以最多包含一个null；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">JDK API 中Set的常用实现类有：HashSet 和 TreeSet；</font>

### <font style="color:rgb(79, 79, 79);">> Set 接口和常用方法</font>
<font style="color:rgb(77, 77, 77);">Set 接口的常用方法</font>

+ <font style="color:rgba(0, 0, 0, 0.75);">和 List 接口一样，Set 接口也是 Collection 的子接口，所以常用方法和Collection接口一样</font>

<font style="color:rgb(77, 77, 77);">Set 接口的遍历方式</font>

+ <font style="color:rgba(0, 0, 0, 0.75);">同 Collection 的遍历一样：</font>
    - <font style="color:rgba(0, 0, 0, 0.75);">迭代器遍历</font>
    - <font style="color:rgba(0, 0, 0, 0.75);">增强 for</font>
    - <font style="color:rgba(0, 0, 0, 0.75);">但</font><font style="color:rgba(0, 0, 0, 0.75);"> </font>**<font style="color:rgba(0, 0, 0, 0.75);">不能用索引</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">的方式来获取； （</font>**<font style="color:rgba(0, 0, 0, 0.75);">因为Set无序</font>**<font style="color:rgba(0, 0, 0, 0.75);">）</font>

```plain
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class SetMethod {
    public static void main(String[] args) {
        //以Set接口的实现类 HashSet 来演示
        //Set接口的实现类对象(Set接口对象)，不能存放重复元素
        //Set接口对象存放和读取数据无序
        //取出的顺序虽然不是添加的顺序，但是，是固定有序的
        Set set = new HashSet();
        set.add("John");
        set.add("Lucy");
        set.add("Jack");
        set.add(null);
        set.add(null);
        System.out.println(set);//[null, John, Lucy, Jack] 执行多遍都是这个结果
		set.remove(null);//等常用方法可以依照Colleciotn常用方法，是一致的

        //遍历：迭代器
        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            Object o = iterator.next();
            System.out.println(o);
        }
        //遍历：增强for （底层还是迭代器）
        for(Object o:set){
            System.out.println(o);
        }
        //不能索引遍历，且set接口对象没有get()方法
    }
}
```

### <font style="color:rgb(79, 79, 79);">> HashSet</font>
1. <font style="color:rgba(0, 0, 0, 0.75);">HashSet实现了Set接口；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">HashSet实际上是HashMap，可以从源码看出；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">可以存放 null 值，但是只能有一个null；</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">HashSet 不保证元素是有序的，取决于hash后，再确定索引的结果；</font>
5. <font style="color:rgba(0, 0, 0, 0.75);">不能有重复元素 / 对象；</font>

```plain
import java.util.HashSet;

public class HashSet01 {
    public static void main(String[] args) {
        HashSet hashSet = new HashSet();
        //1.在执行add方法后，会返回一个boolean值
        //2.如果添加成功，返回true，否则返回false
        System.out.println(hashSet.add("john"));//true
        System.out.println(hashSet.add("lucy"));//true
        System.out.println(hashSet.add("john"));//false
        System.out.println(hashSet.add("jack"));//true
        System.out.println(hashSet.add("rose"));//true
        hashSet.remove("john");//指定删除某对象
        System.out.println("hashset = "+hashSet);//hashset = [rose, lucy, jack]

        hashSet = new HashSet();
        //HashSet不能添加相同的元素、数据
        hashSet.add("lucy");//添加成功
        hashSet.add("lucy");//加入不了
        hashSet.add(new Dog("tom"));//OK
        hashSet.add(new Dog("tom"));//也能加入
        System.out.println("hashset = "+hashSet);//hashset = [Dog{name='tom'}, lucy, Dog{name='tom'}]
        //经典面试题
        hashSet.add(new String("ok"));//可以加入
        hashSet.add(new String("ok"));//无法加入
        System.out.println("hashset = "+hashSet);//hashset = [Dog{name='tom'}, ok, lucy, Dog{name='tom'}]
        //看源码 add到底发生了什么 --》底层机制
    }
}
class Dog{
    private String name;

    public Dog(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

#### <font style="color:rgb(79, 79, 79);">HashSet 底层机制（HashMap）</font>
<font style="color:rgb(77, 77, 77);">HashSet 底层其实是HashMap，HashMap底层是（数组+链表+红黑树）</font>

<font style="color:rgb(77, 77, 77);">模拟数组+链表结构：</font>

1. <font style="color:rgba(0, 0, 0, 0.75);">定义一个数组</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">数组里面放对象</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">一个对象还能指向下一个对象</font>

```plain
public class HashSetStructure {
    public static void main(String[] args) {
        //模拟一个HashSet的底层（HashMap）
        //1.创建一个数组，数组的类型是Node[]
        //2.Node[] 也称为一个表
        Node[] table = new Node[16];
        //3.创建一个节点
        Node john = new Node("john", null);
        table[2] = john;
        Node jack = new Node("jack", null);
        john.next = jack;//将节点挂载到john
        Node rose = new Node("rose",null);
        jack.next = rose;//将rose节点挂载到jack
        Node lucy = new Node( "lucy",null);
        table[3] = lucy;//把lucy放到table表的索引为3的位置
        System.out.println("table = "+table);
    }
}
class Node{//节点，存储数据，可以指向下一个节点，从而形成链表
    Object item;//存放数据
    Node next;//指向下一个节点

    public Node(Object item, Node next) {
        this.item = item;
        this.next = next;
    }
}
```

<font style="color:rgb(77, 77, 77);">debug后解读：  
</font>![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093042875-e1b9b132-4e5b-40aa-882d-14920865ac08.png)

**<font style="color:rgb(77, 77, 77);">HashSet底层机制：</font>**<font style="color:rgb(77, 77, 77);">  
</font>![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093042910-98448141-3de9-4931-adcf-8add916ce538.png)

1. <font style="color:rgba(0, 0, 0, 0.75);">HashSet 底层其实是 HashMap；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">添加一个元素时，先得到 hash值-> 转成->索引值 ；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">找到存储数据表 table ，看这个索引位置是否已经存放的所有元素；</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">如果没有，直接加入；</font>
5. <font style="color:rgba(0, 0, 0, 0.75);">如果有，调用 equals 比较，如果相同，就放弃添加，如果不相同，则添加到最后；</font>
6. <font style="color:rgba(0, 0, 0, 0.75);">在Java8中，如果一条链表的元素个数达到 TREEIFY_THRESHOLD(默认是8)，并且table大小>=MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化（红黑树）；</font>

```plain
用例：
	 定义一个Employee类，该类包含：private成员属性name,age 
要求：
	 1.创建3个Employee对象放入HashSet中；
	 2.当name和age的值相同时，认为是相同员工，不能添加到HashSet集合中；
```

```plain
import java.util.HashSet;
import java.util.Objects;

public class HashSet_Exercise {
    /**
     * 定义一个Employee类，该类包含：private成员属性name,age
     * 1.创建3个Employee对象放入HashSet中；
     * 2.当name和age的值相同时，认为是相同员工，不能添加到HashSet集合中；
     */
    public static void main(String[] args) {
        HashSet hashSet = new HashSet();
        hashSet.add(new Employee("jack",18));
        hashSet.add(new Employee("tom",28));
        hashSet.add(new Employee("rose",18));
        //加入了三个成员
        System.out.println(hashSet);//[Employee{name='jack', age=18}, Employee{name='rose', age=18}, Employee{name='tom', age=28}]
    }
}

//创建Employee
class Employee{
    private String name;
    private int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    //如果name和age相同，则返回相同的hash值
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return age == employee.age && Objects.equals(name, employee.name);
    }
    //name和age相同，hashcode相同
    @Override 
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

---

### <font style="color:rgb(79, 79, 79);">> LinkedHashSet</font>
![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093043127-74b57c92-2925-4d90-ba18-dc800a2f952e.png)

1. <font style="color:rgba(0, 0, 0, 0.75);">LinkedHashSet 是 HashSet 的子类，继承HashSet，实现了Set接口；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个 数组+双向链表；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的；</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">LinkedHashSet 不允许添加重复元素；  
</font>![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093043377-5c22e4fd-fd2c-4b6b-befb-e51889586af7.png)

```plain
import java.util.LinkedHashSet;
import java.util.Set;

public class LinkedHashSetSource {
    public static void main(String[] args) {
        //LinkedHashSet底层机制
        Set set = new LinkedHashSet();
        set.add(new String("OK"));
        set.add(128);
        set.add(128);
        set.add(new Customer("靳",1201));
        set.add("JinYu");
        System.out.println(set);
        //[OK, 128, com.study.set_.Customer@677327b6, JinYu]
        /*
        1.添加元素和取出顺序一致
        2.LinkedHashSet底层维护的是一个LinkedHashMap(是HashMap的子类)
        3.LinkedHashSet底层结构：数组table+双向链表
        4.添加第一次时，直接将数组table扩容到16，存放的结点类型是LinkedHashSetMap$Entry
        5.数组是HashMap$Node[] 存放的元素/数据是LinkedHashSetMap$Entry类型
        */
    }
}
class Customer{
    private String name;
    private int id;

    public Customer(String name, int id) {
        this.name = name;
        this.id = id;
    }
}

```

```plain
示例：Car类（属性name，price），如果name和price一样，则认为是相同元素，就不能添加
```

```plain
import java.util.LinkedHashSet;
import java.util.Objects;
import java.util.Set;

public class LinkedHashSetExercise {
    public static void main(String[] args) {
        Set set = new LinkedHashSet();
        set.add(new Car("奥拓",1000));
        set.add(new Car("奥迪",300000));
        set.add(new Car("法拉利",9000000));
        set.add(new Car("奥迪",300000));
        set.add(new Car("保时捷",1000));
        set.add(new Car("奥迪",300000));
        System.out.println(set);
        /* 未重写equals和hashCode方法：
        [Car{name='奥拓', price=1000.0}
        , Car{name='奥迪', price=300000.0}
        , Car{name='法拉利', price=9000000.0}
        , Car{name='奥迪', price=300000.0}
        , Car{name='保时捷', price=1000.0}
        , Car{name='奥迪', price=300000.0}
        ]*/
        /* 重写equals和hashCode方法后：
        [Car{name='奥拓', price=1000.0}
        , Car{name='奥迪', price=300000.0}
        , Car{name='法拉利', price=9000000.0}
        , Car{name='保时捷', price=1000.0}
        ]
         */
    }
}
class Car{
    private String name;
    private double price;

    public Car(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Car{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}'+"\n";
    }
    //重写equals方法和hashCode方法
    //当name和price相同时，返回相同的hashCode值
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Car car = (Car) o;
        return Double.compare(car.price, price) == 0 && Objects.equals(name, car.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, price);
    }
}
```

### <font style="color:rgb(79, 79, 79);">> TreeSet</font>
<font style="color:rgb(77, 77, 77);">TreeSet的独特之处在于它的构造器可以传入比较器，所以TreeSet常用来排序，</font>

<font style="color:rgb(77, 77, 77);">TreeSet 底层是 TreeMap</font>

```plain
import java.util.Comparator;
import java.util.TreeSet;

public class TreeSet_ {
    public static void main(String[] args) {
        TreeSet treeSet = new TreeSet();//无参构造，默认排序
        //添加数据
        treeSet.add("Jack");
        treeSet.add("Tom");
        treeSet.add("Ayo");
        treeSet.add("Luck");
        System.out.println(treeSet);//默认排序：首字母ASCII由小到大
        //[Ayo, Jack, Luck, Tom]

        //如果我们想按字符串大小排序
        //使用TreeSet提供的一个构造器，传入一个比较器（匿名内部类）指定排序规则
        treeSet = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String)o2).compareTo((String)o1);//利用String类的compareTo方法，由大到小
                //如果是按照长度由大到小：return ((String)o1).length()-((String)o2).length();
            }//构造器把传入的比较器对象，赋给了TreeSet的底层的TreeMap的属性this.comparator
        });
        treeSet.add("Jack");
        treeSet.add("Tom");
        treeSet.add("Ayo");
        treeSet.add("Luck");
        System.out.println(treeSet);//[Tom, Luck, Jack, Ayo]
    }
}
```

---

## <font style="color:rgb(79, 79, 79);">05 Map接口</font>
![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093043617-4af0ed71-4de9-4248-867b-4d30da0ac1d1.png)<font style="color:rgb(77, 77, 77);">  
</font><font style="color:rgb(77, 77, 77);">Map为双列集合，Set集合的底层也是Map，只不过有一列是常量所占，只使用到了一列。</font>

### <font style="color:rgb(79, 79, 79);">> Map 接口实现类的特点</font>
1. <font style="color:rgba(0, 0, 0, 0.75);">Map 与 Collection 并列存在，用于保存具有映射关系的数据：Key - Value；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">Map 中的 Key 和 Value 可以是任何引用类型的数据，会封装到 HashMap$Node对象中；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">Map中的 Key 不允许重复，原因和</font><font style="color:rgba(0, 0, 0, 0.75);"> </font>[<font style="color:rgba(0, 0, 0, 0.75);">HashSet</font>](https://blog.csdn.net/Lov1_BYS/article/details/128637518)<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">一样;</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">Map 中的 Value 可以重复；</font>
5. <font style="color:rgba(0, 0, 0, 0.75);">Map 的 Key 可以为 null，value 也可以为 null，但 key 为 null 只能有一个；</font>
6. <font style="color:rgba(0, 0, 0, 0.75);">常用 String 类作为 Map 的 key，当然，其他类型也可以，但不常用；</font>
7. <font style="color:rgba(0, 0, 0, 0.75);">Key 和 Value 之间存在单向一对一关系，即通过指定的 Key 总能找到对应的 Value；</font>

```plain
import java.util.HashMap;
import java.util.Map;

public class Map_ {
    //分析Map接口实现类的特点
    public static void main(String[] args){
        //1. Map 与 Collection 并列存在，用于保存具有映射关系的数据：Key - Value；
        Map map = new HashMap();
        map.put("No.1","我");//Key-Value
        map.put("No.2","你");// K-V
        map.put("No.3","他");// K-V
        System.out.println(map);//{No.2=你, No.1=我, No.3=他}
        //2. Map 中的 Key 和 Value 可以是任何引用类型的数据，会封装到 HashMap$Node对象中
        //3. Map中的 Key 不允许重复，原因和HashSet一样
        //4.Map 中的 Value 可以重复
        map.put("No.2","X"); //替换机制
        map.put("No.4","他");
        System.out.println(map);//{No.2=X, No.1=我, No.4=他, No.3=他}
        //5. Map 的 Key 可以为 null，value 也可以为 null，但 key 为 null 只能有一个；
        map.put("null","1");
        map.put("null","2");
        map.put("No.2","null");
        map.put("No.3","null");
        System.out.println(map);//{No.2=null, No.1=我, No.4=他, No.3=null, null=2}
        //6. 常用 String 类作为 Map 的 key，当然，其他类型也可以，但不常用；
        //7. Key 和 Value 之间存在单向一对一关系，即通过指定的 Key 总能找到对应的 Value；
        //通过get方法，传入key，会返回对应的value
        System.out.println(map.get("No.1"));//我
    }
}
```

1. <font style="color:rgba(0, 0, 0, 0.75);">Map 存放数据的 key - value 示意图，一对 k - v 是放在一个 HashMap$Node 中的，又因为 Node 实现了 Entry 接口，所以也可以说，一对 k - v 就是一个 Entry ；</font>

![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093043629-d3c50dfa-34c6-44f9-ac50-d57b1d0e6e74.png)

### <font style="color:rgb(79, 79, 79);">> Map 接口和常用方法</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">put ：添加</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">remove ： 根据键删除映射关系</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">get ： 根据键获取值</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">size ： 获取元素个数</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">isEmpty ： 判断个数是否为0</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">clear ： 清除</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">containsKey ： 查找键是否存在</font>

```plain
import java.util.HashMap;
import java.util.Map;
    //演示 Map 接口常用方法
public class MapMethod {
    public static void main(String[] args) {
        Map map = new HashMap();
        //put方法：添加元素
        map.put("海绵宝宝","章鱼哥");
        map.put("海绵宝宝","派大星");
        map.put("熊大","熊二");
        map.put("大头儿子","小头爸爸");
        map.put("黑猫警长",null);
        map.put(null,"奥特曼");
        System.out.println(map);//{黑猫警长=null, null=奥特曼, 大头儿子=小头爸爸, 熊大=熊二, 海绵宝宝=派大星}
        //remove方法：根据键删除映射关系
        map.remove(null);
        System.out.println(map);//{黑猫警长=null, 大头儿子=小头爸爸, 熊大=熊二, 海绵宝宝=派大星}
        //get方法：根据键获取
        System.out.println(map.get("海绵宝宝"));//派大星
        //size方法：获取元素个数
        System.out.println(map.size());//4
        //isEmpty方法：判断个数是否为0
        System.out.println(map.isEmpty());//false
        //containsKey方法：查找键是否存在
        System.out.println(map.containsKey("黑猫警长"));//true
        //clear方法：清空
        map.clear();
        System.out.println(map);//{}
    }
}
```

### <font style="color:rgb(79, 79, 79);">> Map 接口遍历方法</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">containsKey ： 查找键是否存在</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">keySet ： 获取所有的键</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">entrySet ：获取所有关系</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">values ： 获取所有的值</font>

```plain
import java.util.*;

public class MapFor {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("海绵宝宝","派大星");
        map.put("熊大","熊二");
        map.put("大头儿子","小头爸爸");
        map.put("黑猫警长",null);
        map.put(null,"奥特曼");
        //第一种：先取出所有的Key，通过Key取出对应的value
        Set keySet = map.keySet();
        //(1)增强for
        for(Object key : keySet){
            System.out.println(key+" - "+map.get(key));
        }
        //(2)迭代器
        Iterator iterator = keySet.iterator();
        while (iterator.hasNext()) {
            Object key =  iterator.next();
            System.out.println(key+" - "+map.get(key));
        }

        //第二种：把所有的value取出
        Collection values = map.values();
        //然后遍历Collection就行
        //(1)增强for
        for(Object value : values){
            System.out.println(value);
        }
        //(2)迭代器
        Iterator iterator1 = values.iterator();
        while (iterator1.hasNext()) {
            Object value =  iterator1.next();
            System.out.println(value);
        }

        //第三种：通过EntrySet来获取
        Set entrySet = map.entrySet();
        //(1)增强for
        for(Object entry : entrySet){
            //将entry转成map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey()+" - "+m.getValue());
        }
        //(2)迭代器
        Iterator iterator2 = entrySet.iterator();
        while (iterator2.hasNext()) {
            Object next = iterator2.next();
            //向下转型 Map.Entry
            Map.Entry m  =  (Map.Entry) next;
            System.out.println(m.getKey()+" - "+m.getValue());
        }
    }
}
```

### <font style="color:rgb(79, 79, 79);">> HashMap 用例 小结</font>
```plain
使用 HashMap 添加3个员工对象，要求：
键：员工id
值：员工对象
并遍历显示工资 > 18000的员工
（员工类：姓名，工资，员工id）
```

```plain
import java.util.*;

public class MapExercise {
    public static void main(String[] args) {
        //创建、添加
        HashMap hashMap = new HashMap();
        hashMap.put(1,new Emp("Jack",30000,1));
        hashMap.put(2,new Emp("Tom",20000,2));
        hashMap.put(3,new Emp("Milan",12000,3));
        //遍历一：使用keySet -> 增强for
        Set keySet = hashMap.keySet();
        for(Object key : keySet){
            //先获取value
            Emp emp = (Emp) hashMap.get(key);
            //薪水大于18000就打印
            if(emp.getSal() > 18000){
                System.out.println(emp);
            }
        }
        //遍历二：使用EntrySet -> 迭代器
        Set entrySet = hashMap.entrySet();
        Iterator iterator = entrySet.iterator();
        while (iterator.hasNext()) {
            Map.Entry entry =  (Map.Entry)iterator.next();
            //通过entry取得key和value
            Emp emp = (Emp) entry.getValue();
            if(emp.getSal() > 18000){
                System.out.println(emp);
            }
        }
    }
}
class  Emp{
    private String name;
    private double sal;
    private int id;

    public Emp(String name, double sal, int id) {
        this.name = name;
        this.sal = sal;
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSal() {
        return sal;
    }

    public void setSal(double sal) {
        this.sal = sal;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "Emp{" +
                "name='" + name + '\'' +
                ", sal=" + sal +
                ", id=" + id +
                '}';
    }
}
```

1. <font style="color:rgba(0, 0, 0, 0.75);">Map 接口的常用实现类：HashMap、Hashtable、Properties;</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">HashMap 是 Map 接口使用频率最高的实现类；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">HashMap 是以 key - value 对的形式来存储的；</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">key 不能重复添加，但value可以，都允许使用null；</font>
5. <font style="color:rgba(0, 0, 0, 0.75);">如果添加相同的 key，则会覆盖原来的 key - value，等同于修改；</font>
6. <font style="color:rgba(0, 0, 0, 0.75);">与 HashSet一样，不保证映射的顺序，因为底层是以hashbiao的方式来存储的；</font>
7. <font style="color:rgba(0, 0, 0, 0.75);">HashMap 没有实现同步，所以线程不安全；</font>

#### <font style="color:rgb(79, 79, 79);">HashMap 底层&扩容机制</font>
![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093043672-6f0408dc-679c-444a-b6e2-ed518098443b.png)

1. <font style="color:rgba(0, 0, 0, 0.75);">HashMap 底层维护了 Node 类型的数组 table ，默认为 null；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">当创建对象时，将加载因子（loadfactor）初始化为0.75；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">当添加 key-value 时，通过 key 的哈希值得到在 table的索引，然后判断该索引处是否有元素，如果没有元素则直接添加。如果该索引处有元素，继续判断该元素的 key 是否和准备加入的 key 相等，如果相等，则直接替换 value；如果不相等，则需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。（扩容机制和HashSet完全一样，因为HashSet底层就是HashMap）</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">第一次添加，会扩容 table 容量为16，临界值（threshold）为12；</font>
5. <font style="color:rgba(0, 0, 0, 0.75);">以后再扩容，会扩容 table 容量为原来的2倍，临界值为原来的2倍，即24，以此类推；</font>
6. <font style="color:rgba(0, 0, 0, 0.75);">在Java8中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD（默认是8），并且 table的大小>= MIN_CAPACITY（默认是64），就会进行树化（红黑树）；</font>

---

### <font style="color:rgb(79, 79, 79);">> Hashtable</font>
**<font style="color:rgb(77, 77, 77);">Hashtable的基本介绍：</font>**

1. <font style="color:rgba(0, 0, 0, 0.75);">存放的元素都是键值对，即 key - value；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">Hashtable 的键和值都不能为 null，否则会抛出NullPointerException</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">Hashtable 使用方法基本上和 HashMap 一样；</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">Hashtable 是线程安全的（synchronized）， HashMap是线程不安全的；</font>

```plain
Hashtabel table =  new Hashtable();
table.put("John",100);//OK
table.put(null,100);//异常 NullPointerException
table.put("",null);//异常
table.put("John",128);//替换
```

```plain
Hashtable的底层原理：
1.底层有数组 Hashtables$Entry[] 初始化大小为1；
2.临界值 threshold 8 = 11 * 0.75；
3.扩容机制：执行方法 addEntry(hash,key,value,index);添加 K-V，封装到Entry；
4.当 if(count >= threshold) 满足就扩容；
5.按照 int newCapacity = (oldCapacity << 1)+1; 扩容
```

| **<font style="color:rgb(79, 79, 79);">对比</font>** | **<font style="color:rgb(79, 79, 79);">线程安全（同步）</font>** | **<font style="color:rgb(79, 79, 79);">效率</font>** | **<font style="color:rgb(79, 79, 79);">允许 null 键 null 值</font>** |
| :---: | :---: | :---: | :---: |
| <font style="color:rgb(79, 79, 79);">HashMap</font> | <font style="color:rgb(79, 79, 79);">不安全</font> | <font style="color:rgb(79, 79, 79);">高</font> | <font style="color:rgb(79, 79, 79);">可以</font> |
| <font style="color:rgb(79, 79, 79);">Hashtable</font> | <font style="color:rgb(79, 79, 79);">安全</font> | <font style="color:rgb(79, 79, 79);">较低</font> | <font style="color:rgb(79, 79, 79);">不可以</font> |


---

### <font style="color:rgb(79, 79, 79);">> TreeMap</font>
<font style="color:rgb(77, 77, 77);">TreeMap 构造器可以传入比较器，所以TreeMap常用来排序，可以自定义存放数据顺序。</font>

```plain
import java.util.Comparator;
import java.util.TreeMap;

public class TreeMap_ {
    public static void main(String[] args) {
        TreeMap treeMap = new TreeMap();//默认构造器，默认比较：自然排序
        treeMap.put("Jack","杰克");
        treeMap.put("Tom","汤姆");
        treeMap.put("Smith","史密斯");
        System.out.println(treeMap);//{Jack=杰克, Smith=史密斯, Tom=汤姆}由小到大排序

        //如果按照传入的key由大到小排序：
        treeMap = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String)o2).compareTo((String)o1);
                //如果是按照长度由大到小：return ((String)o1).length()-((String)o2).length(); 
            }
        });
        treeMap.put("Jack","杰克");
        treeMap.put("Tom","汤姆");
        treeMap.put("Smith","史密斯");
        System.out.println(treeMap);//{Tom=汤姆, Smith=史密斯, Jack=杰克} 由大到小排序
    }
}
```

---

### <font style="color:rgb(79, 79, 79);">> Properties</font>
1. <font style="color:rgba(0, 0, 0, 0.75);">Properties 类继承自 Hashtable 类并且实现了Map接口，也是使用一种键值对的形式来保存数据；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">使用特点和 Hashtable 相似；</font>
3. <font style="color:rgba(0, 0, 0, 0.75);">Properties 还可以用于从 xxx.properties 文件中，加载数据到Properties类对象，并进行读取和修改；</font>
4. <font style="color:rgba(0, 0, 0, 0.75);">说明：xxx.properties 文件通常作为配置文件，这在</font><font style="color:rgba(0, 0, 0, 0.75);"> </font>[<font style="color:rgba(0, 0, 0, 0.75);">IO流</font>](https://blog.csdn.net/Lov1_BYS/article/details/128070531?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522640B3F6A-AF47-4D3A-A825-46B3AECC94A1%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=640B3F6A-AF47-4D3A-A825-46B3AECC94A1&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-128070531-null-null.142^v100^pc_search_result_base7&utm_term=Java%E9%9B%86%E5%90%88&spm=1018.2226.3001.4187)<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">也有讲解</font>

<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">👉</font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);"> </font>[<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">Properties博客介绍</font>](https://www.cnblogs.com/xudong-bupt/p/3758136.html)

---

## <font style="color:rgb(79, 79, 79);">06 Collections工具类介绍</font>
1. <font style="color:rgba(0, 0, 0, 0.75);">Collections 是一个操作 Set、List 和 Map 等集合的工具类；</font>
2. <font style="color:rgba(0, 0, 0, 0.75);">Collections 中提供了一系列静态方法对集合元素进行排序、查询和修改操作；</font>

### <font style="color:rgb(79, 79, 79);">> 排序操作</font>
<font style="color:rgb(77, 77, 77);">均为static方法：</font>

+ **<font style="color:rgba(0, 0, 0, 0.75);">reverse （List）</font>**<font style="color:rgba(0, 0, 0, 0.75);">：反转 List 中元素的排序；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">shuffle （List）</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 对 List 集合元素进行随机排序；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">sort （List）</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 根据元素的自然顺序对指定的 List 集合元素按升序排序；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">sort （List，Comparator）</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">swap （List ，int，int）</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">：将指定 List 集合中的 i 处元素 和 j 处元素进行交换；</font>

```plain
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Collections_ {
    public static void main(String[] args) {
        //创建ArrayList集合，用于测试
        List list = new ArrayList();
        list.add("Jack");
        list.add("Tom");
        list.add("Smith");
        list.add("Rose");

        //reverse(List)：反转List集合中的元素顺序
        Collections.reverse(list);
        System.out.println(list);//[Rose, Smith, Tom, Jack]

        //shuffle(List)：对List集合进行随机排序
        Collections.shuffle(list);
        System.out.println(list);//[Rose, Tom, Smith, Jack]

        //sort(List)：根据元素的自然顺序对指定的List集合元素按升序排序
        Collections.sort(list);
        System.out.println(list);//[Jack, Rose, Smith, Tom]

        //sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序；
        Collections.sort(list,new Comparator(){
            @Override
            public int compare (Object o1,Object o2){
                //根据字符串长度大小排序
                return ((String)o1).length()-((String)o2).length();
            }
        });
        System.out.println(list);//[Tom, Jack, Rose, Smith]

        //swap(List,i,j): 将指定List集合中的i处元素和j处元素进行交换
        Collections.swap(list,1,2);
        System.out.println(list);//[Tom, Rose, Jack, Smith]
    }
}
```

### <font style="color:rgb(79, 79, 79);">> 查找、替换</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">Object max ( Collection )</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">：根据元素的自然顺序，返回给定集合中的最大元素；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">Object max ( Collection , Comparator )</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">：根据 Comparator 指定的顺序，返回给定集合中的最大元素；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">Object min ( Collection )</font>**
+ **<font style="color:rgba(0, 0, 0, 0.75);">Object min ( Collection , Comparator)</font>**
+ **<font style="color:rgba(0, 0, 0, 0.75);">int frequency ( Collection , Object )</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 返回指定集合中指定元素的出现次数；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">void copy ( List dest , List src )</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 将 src 中的内容复制到 dest 中；</font>
+ **<font style="color:rgba(0, 0, 0, 0.75);">boolean replaceAll ( List list , Object oldVal , Object newVal )</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">： 使用新值替换List对象的所有旧值；</font>

```plain
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Collections__ {
    public static void main(String[] args) {
        //创建ArrayList集合，用于测试
        List list = new ArrayList();
        list.add("Jack");
        list.add("Tom");
        list.add("Smith");
        list.add("Rose");

        // Object max ( Collection ) ：根据元素的自然顺序，返回给定集合中的最大元素；
        System.out.println("自然顺序最大值 = "+ Collections.max(list));//Tom

        // Object max ( Collection , Comparator ) ：根据 Comparator 指定的顺序，返回给定集合中的最大元素；
        //返回长度最大的元素：
        Collections.max(list, new Comparator() {
            @Override
            public int compare(Object o1 , Object o2){
                return ((String)o1).length()-((String)o2).length();
            }
        });
        //  Object min ( Collection )
        //  Object min  ( Collection , Comparator)

        // int frequency ( Collection , Object )  ： 返回指定集合中指定元素的出现次数；
        System.out.println(Collections.frequency(list,"Rose"));//1
        list.add("Rose");
        System.out.println(Collections.frequency(list,"Rose"));//2

        // void copy ( List dest  , List src ) ： 将 src  中的内容复制到 dest  中；
        //为了完成一个完整拷贝，需要先给dest赋值，大小和list.size()一样
        ArrayList dest = new ArrayList();
        for(int i=0;i<list.size();i++){
            dest.add(null);
        }
        Collections.copy(dest,list);
        System.out.println(dest);//[Jack, Tom, Smith, Rose, Rose]


        // boolean replaceAll  ( List list , Object oldVal , Object newVal ) ： 使用新值替换List对象的所有旧值；
        //如果list中有tom,就替换为汤姆
        Collections.replaceAll(list,"Tom","汤姆");
        System.out.println(list);//[Jack, 汤姆, Smith, Rose, Rose]
    }
}
```

---

## <font style="color:rgb(79, 79, 79);">👉</font><font style="color:rgb(79, 79, 79);"> 开发中如何选择集合实现类</font>
<font style="color:rgb(77, 77, 77);">在实际开发中，选择什么集合实现类，主要取决于业务操作的特点，然后根据集合实现类特性进行选择：</font>

**<font style="color:rgb(77, 77, 77);">先判断存储的类型（一组对象或一组键值对）</font>**<font style="color:rgb(77, 77, 77);">：</font>

+ <font style="color:rgba(0, 0, 0, 0.75);">一组对象 【单列】：Collection 接口</font>
    - <font style="color:rgba(0, 0, 0, 0.75);">允许重复：List</font>
        * <font style="color:rgba(0, 0, 0, 0.75);">增删多：LinkedList （底层维护了一个双向链表）</font>
        * <font style="color:rgba(0, 0, 0, 0.75);">改查多：ArrayList（底层维护 Object类型的可变数组）</font>
    - <font style="color:rgba(0, 0, 0, 0.75);">不允许重复：Set</font>
        * <font style="color:rgba(0, 0, 0, 0.75);">无序：HashSet（底层是HashMap，维护了一个哈希表，即数组+链表+红黑树）</font>
        * <font style="color:rgba(0, 0, 0, 0.75);">排序：TreeSet</font>
        * <font style="color:rgba(0, 0, 0, 0.75);">插入和取出顺序一致：LinkedHashSet（维护数组+双向链表）</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">一组键值对 【双列】：Map</font>
    - <font style="color:rgba(0, 0, 0, 0.75);">键无序：HashMap（底层是哈希表，JDK8:数组+链表+红黑树）</font>
    - <font style="color:rgba(0, 0, 0, 0.75);">键排序：TreeMap</font>
    - <font style="color:rgba(0, 0, 0, 0.75);">键插入和取出顺序一致：LinkedHashMap</font>
    - <font style="color:rgba(0, 0, 0, 0.75);">读取文件：Properties  
</font>![](https://cdn.nlark.com/yuque/0/2024/png/46412986/1728093043941-0de31e2c-662b-475a-b9a7-30a6750cd990.png)

## Properties
### Properties的常用方法：


| setProperty(String key, String value)	 | 调用 Hashtable 的方法 put。 |
| --- | --- |
| getProperty(String key) | 用指定的键在此属性列表中搜索属性 |
| getProperty(String key, StringdefaultValue) | 用指定的键在属性列表中搜索属性。 |
| load(InputStream inStream)	 | 从输入流中读取属性列表（键和元素对） |
| load(Reader reader) | 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对） |
| loadFromXML(InputStream in) | 将指定输入流中由 XML 文档所表示的所有属性加载到此属性表中 |
| store(OutputStream out, String comments) | 以适合使用 load(InputStream) 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流 |
| store(Writer writer, String comments) | 以适合使用 load(Reader) 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符 |
| storeToXML(OutputStream os, String comment) | 发出一个表示此表中包含的所有属性的 XML 文档 |
| storeToXML(OutputStream os, String comment, String encoding) | 使用指定的编码发出一个表示此表中包含的所有属性的 XML 文档 |


```plain
package 集合;

import java.io.*;
import java.util.Properties;

public class PropertiesTest {
    public static void main(String[] args) {
//为properties对象添加属性和获取值
        Properties p = new Properties();
        p.setProperty("name", "zhangsan");
        p.setProperty("age", "20");
        p.setProperty("sex", "男");
        System.out.println(p.getProperty("name"));
        System.out.println(p.getProperty("age"));
        System.out.println(p.getProperty("sex"));
        // 遍历
        for (String key : p.stringPropertyNames()) {
            System.out.println(key + ":" + p.getProperty(key));
        }

//properties配置文件格式写入到硬盘中的某个文件夹
        try {
            p.store(new FileOutputStream(new File("E:\\toolbox\\java\\测试\\src\\test.properties")), "propertiesTest");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

//properties加载和读取配置文件（以properties文件为例）
        Properties pro;
        try {
            pro=new Properties();
            //通过字节输入流
            //load(InputStream inStream)
            //pro.load(new FileInputStream("src/test.properties"));

            //通过类加载器 获取当前类路径
            //类路径是指      / bin路径
            //pro.load(this.getClass().getResourceAsStream("/test.properties"));
            //pro.load(this.getClass().getClassLoader().getResourceAsStream("test.properties"));

            //也可以使用当前上下文的类加载器，不用“/”
            pro.load(Thread.currentThread().getContextClassLoader().getResourceAsStream("test.properties"));

            //通过字符输入流
            //load(Reader reader)
            //pro.load(new FileReader("src/test.properties"));
            for(String key: pro.stringPropertyNames())
                System.out.println(key + ":" + p.getProperty(key));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

## ResourceBundle中获取值
获取ResourceBundle实例后可以通过下面的方法获得本地化值。

> getObject(String key);  
getString(String key);  
getStringArray(String key);
>

  
还可以通过keySet()方法获取所有的key。Set keys = bundle.keySet();  
其它ResourceBundle 方法可以通过查看文档获得。

测试及验证



> 新建4个属性文件  
my_en_US.properties：cancelKey=cancel
>
> my_zh_CN.properties：cancelKey=\u53D6\u6D88（取消）
>
> my_zh.properties：cancelKey=\u53D6\u6D88zh（取消zh）
>
> my.properties：cancelKey=\u53D6\u6D88default（取消default）
>



获取bundle

> ResourceBundle bundle = ResourceBundle.getBundle("res", new Locale("zh", "CN"));
>

  
其中new Locale(“zh”, “CN”)提供本地化信息，上面这行代码，程序会首先在classpath下寻找my_zh_CN.properties文件，若my_zh_CN.properties文件不存在，则取找my_zh.properties，如还是不存在，继续寻找my.properties,若都找不到就抛出异常。

```java
import javax.annotation.Resource;
import java.util.Locale;
import java.util.ResourceBundle;

/**
 * @author OovEver
 * 2018/1/14 22:12
 */
public class Main {

    public static void main(String args[]) {
        ResourceBundle bundle = ResourceBundle.getBundle("my", new Locale("zh", "CN"));
        String cancel = bundle.getString("cancelKey");
        System.out.println(cancel);

        bundle = ResourceBundle.getBundle("my", Locale.US);
        cancel = bundle.getString("cancelKey");
        System.out.println(cancel);

        bundle = ResourceBundle.getBundle("my", Locale.getDefault());
        cancel = bundle.getString("cancelKey");
        System.out.println(cancel);

        bundle = ResourceBundle.getBundle("my", Locale.GERMAN);
        cancel = bundle.getString("cancelKey");
        System.out.println(cancel);
        bundle = ResourceBundle.getBundle("my");
        for (String key : bundle.keySet()) {
            System.out.println(bundle.getString(key));
        }
    }
}
```

